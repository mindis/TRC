package DataManager;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Stack;

import Common.Instruction;

public class DM {
	public static int bufferSize = 268435456;  //in Byte
	
	public static int PAGE_SIZE = 512;  //in byte
	
	public static int L1_PAGE_SIZE = PAGE_SIZE/34; //number of records in L1 page 
	
	public static int L2_PAGE_SIZE1 = PAGE_SIZE/22; //number of records for column 1 in L2/Disk page 
	
	public static int L2_PAGE_SIZE2 = PAGE_SIZE/16; //number of records for column 2 in L2/Disk page 
	
	public static int L1_SIZE = bufferSize/PAGE_SIZE/4; //in pages
	
	public static int L2_SIZE = bufferSize/PAGE_SIZE/4*3; //in pages
	
	public static ArrayList<DMLog> DMLogger = new ArrayList<DMLog>();
	
	public static HashMap<String, Stack> transactionLogMap = new HashMap<String, Stack>();
	
	public static HashMap<String, Integer> violateContraintMap = new HashMap<String, Integer>();
	
	/*
	 * Used for "D table" operation
	 * Before commit, the related pages will be marked as "deleted" while keeping the before image,
	 * the pages will be cleared when committing, or revert to original otherwise
	 */
	public static HashMap<String, ArrayList> toDeleteMap = new HashMap<String, ArrayList>();	
	
	public static void execute(ArrayList<Instruction> instructionList){
		Iterator it = instructionList.iterator();
		while(it.hasNext()){
			Instruction inst = (Instruction) it.next();
			
			if(inst.command.equalsIgnoreCase("B")){
				DMLog log = new DMLog(1, inst.transactionID, inst.command, null, null, true);
				transactionLogMap.put(inst.transactionID, new Stack());
				transactionLogMap.get(inst.transactionID).push(log);
				DMLogger.add(log);
				
			}else if(inst.command.equalsIgnoreCase("C")){
				Integer violation = violateContraintMap.get(inst.transactionID);
				if(violation==1){
					Abort(inst.transactionID);
				}else{
					Commit(inst.transactionID);
				}
				
			}else if(inst.command.equalsIgnoreCase("A") || inst.command.equalsIgnoreCase("K")){
				Abort(inst.transactionID);
				
			}else if(inst.command.equalsIgnoreCase("R")){
				DMLog log = new DMLog(1, inst.transactionID, inst.command, inst.table, null, true);
				Read(inst);
				log.setFinishtTimestamp();
				DMLogger.add(log);
				
				
			}else if(inst.command.equalsIgnoreCase("M")){
				MultipleRead(inst);
				
			}else if(inst.command.equalsIgnoreCase("W")){
				Write(inst);
				
			}else if(inst.command.equalsIgnoreCase("D")){
				Delete(inst.table);
				
			}else if(inst.command.equalsIgnoreCase("G")){
				Count(inst.data);
				
			}else if(inst.command.equalsIgnoreCase("E")){
				Finish();
			}
		}
		
	}

	
	/*
	 * Command 'R'
	 */
	public static Tuple Read(Instruction inst){
		
		 // Read from L1-delta
		ArrayList l1pages = L1_delta.tablePages.get(inst.table);
		for(int i=0;i<l1pages.size();i++){
			Page page = (Page) l1pages.get(i);
			if(page.checkIfDeleted()){
				continue;
			}else{
				Iterator it = page.records.iterator();
				while(it.hasNext()){
					Tuple row = (Tuple) it.next();
					if(inst.data.equals(String.valueOf(row.ID))){
						return row;
					}
				}
			}
		}
		
		//Read from L2-delta
		boolean foundCol1 = false;
		boolean foundCol2 = false;
		Tuple result = null;
		ArrayList pages = L2_delta.tablePages.get(inst.table+"-"+"ClientName");
		for(int i=0;i<pages.size() && (!foundCol1);i++){
			Page page = (Page) pages.get(i);
			if(page.checkIfDeleted()){
				continue;
			}else{
				Iterator it = page.records.iterator();
				while(it.hasNext() && (!foundCol1)){
					Tuple row = (Tuple) it.next();
					if(inst.data.equals(String.valueOf(row.ID))){
						result = new Tuple(row.ID,row.ClientName,"");
						foundCol1 = true;
						page.setTimestamp();
					}
				}
			}
		}
		
		pages = L2_delta.tablePages.get(inst.table+"-"+"Phone");
		for(int i=0;i<pages.size() && (!foundCol2);i++){
			Page page = (Page) pages.get(i);
			if(page.checkIfDeleted()){
				continue;
			}else{
				Iterator it = page.records.iterator();
				while(it.hasNext() && (!foundCol2)){
					Tuple row = (Tuple) it.next();
					if(inst.data.equals(String.valueOf(row.ID))){
						result = new Tuple(row.ID,"",row.Phone);
						foundCol2 = true;
						page.setTimestamp();
					}
				}
			}
		}
		
		if(!foundCol1){
			
		}
		
		if(!foundCol2){
			
		}
		
		
		
		 
		return result;
		
	}
	
	/*
	 * Command 'M table val'
	 */
	public static ArrayList MultipleRead(Instruction inst){
		
		return null;
		
	}
	
	public static void Abort(String transactionID){
		
	}
	
	public static void Commit(String transactionID){
		
	}
	
	public static void Write(Instruction inst){
		
	}
	
	public static void Delete(String table){
		
	}
	
	public static void Count(String areaCode){
		
	}
	
	public static void Finish(){
		Utils.L1_L2_Merge();
		Utils.flushAllL2ToDisk();
		
	}
	
	
	

}
